<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Hardware Locality (hwloc): Memory binding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hardware Locality (hwloc)&#160;<span id="projectnumber">1.2.2</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory binding</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> { <br/>
&#160;&#160;<a class="el" href="a00044.html#ggac9764f79505775d06407b40f5e4661e8a18675bb80ebc1bce5b652e9de8f3998c">HWLOC_MEMBIND_DEFAULT</a>, 
<a class="el" href="a00044.html#ggac9764f79505775d06407b40f5e4661e8a979c7aa78dd32780858f30f47a72cca0">HWLOC_MEMBIND_FIRSTTOUCH</a>, 
<a class="el" href="a00044.html#ggac9764f79505775d06407b40f5e4661e8ad811fa4b2a6002c4d63695a408ffde2c">HWLOC_MEMBIND_BIND</a>, 
<a class="el" href="a00044.html#ggac9764f79505775d06407b40f5e4661e8ae370075e5af016d42310f87ea5af236b">HWLOC_MEMBIND_INTERLEAVE</a>, 
<br/>
&#160;&#160;<a class="el" href="a00044.html#ggac9764f79505775d06407b40f5e4661e8afb37480fe5f4236eb7dd4aef26f691e9">HWLOC_MEMBIND_REPLICATE</a>, 
<a class="el" href="a00044.html#ggac9764f79505775d06407b40f5e4661e8aecdd4164d647708fbb51a00d98dbb138">HWLOC_MEMBIND_NEXTTOUCH</a>, 
<a class="el" href="a00044.html#ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402">HWLOC_MEMBIND_MIXED</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gab00475fd98815bf4fb9aaf752030e7d2">hwloc_membind_flags_t</a> { <br/>
&#160;&#160;<a class="el" href="a00044.html#ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4">HWLOC_MEMBIND_PROCESS</a>, 
<a class="el" href="a00044.html#ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298">HWLOC_MEMBIND_THREAD</a>, 
<a class="el" href="a00044.html#ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6">HWLOC_MEMBIND_STRICT</a>, 
<a class="el" href="a00044.html#ggab00475fd98815bf4fb9aaf752030e7d2aa6e49e54f52827cb143cc869cfd748af">HWLOC_MEMBIND_MIGRATE</a>, 
<br/>
&#160;&#160;<a class="el" href="a00044.html#ggab00475fd98815bf4fb9aaf752030e7d2aad6b9eaf2ee324ca58dc8f58094b9997">HWLOC_MEMBIND_NOCPUBIND</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga747962cbb16fd12ad6d126011c734a27">hwloc_set_membind_nodeset</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00034.html#ga2f5276235841ad66a79bedad16a5a10c">hwloc_const_nodeset_t</a> nodeset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga8b6d1d90227aff8e44ef26bc1f8a8f95">hwloc_set_membind</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00034.html#ga1f784433e9b606261f62d1134f6a3b25">hwloc_const_cpuset_t</a> cpuset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga7b46a4ca0b2db9723ca73b0c148ccd93">hwloc_get_membind_nodeset</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00034.html#ga37e35730fa7e775b5bb0afe893d6d508">hwloc_nodeset_t</a> nodeset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gab07aedba1119f99130e5f0b796b7d8a5">hwloc_get_membind</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, <a class="el" href="a00034.html#ga4bbf39b68b6f568fb92739e7c0ea7801">hwloc_cpuset_t</a> cpuset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gaf10d18cd4703ec980d7440a1c23fa07f">hwloc_set_proc_membind_nodeset</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, hwloc_pid_t pid, <a class="el" href="a00034.html#ga2f5276235841ad66a79bedad16a5a10c">hwloc_const_nodeset_t</a> nodeset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gac63c4517e71b3f0d41b3dee3e83dc55c">hwloc_set_proc_membind</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, hwloc_pid_t pid, <a class="el" href="a00034.html#ga1f784433e9b606261f62d1134f6a3b25">hwloc_const_cpuset_t</a> cpuset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga22074ed072e1039f74f17f7b16e9e39d">hwloc_get_proc_membind_nodeset</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, hwloc_pid_t pid, <a class="el" href="a00034.html#ga37e35730fa7e775b5bb0afe893d6d508">hwloc_nodeset_t</a> nodeset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gabaf9c13f1fa301d6895594cec52226e2">hwloc_get_proc_membind</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, hwloc_pid_t pid, <a class="el" href="a00034.html#ga4bbf39b68b6f568fb92739e7c0ea7801">hwloc_cpuset_t</a> cpuset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gade5e2c28ea8475a479bf2b1df36c6ccd">hwloc_set_area_membind_nodeset</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, const void *addr, size_t len, <a class="el" href="a00034.html#ga2f5276235841ad66a79bedad16a5a10c">hwloc_const_nodeset_t</a> nodeset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga06594edeb4728cb9e014aed924d1e74a">hwloc_set_area_membind</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, const void *addr, size_t len, <a class="el" href="a00034.html#ga1f784433e9b606261f62d1134f6a3b25">hwloc_const_cpuset_t</a> cpuset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga106e6fcd764d17be682faf7a5bc95720">hwloc_get_area_membind_nodeset</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, const void *addr, size_t len, <a class="el" href="a00034.html#ga37e35730fa7e775b5bb0afe893d6d508">hwloc_nodeset_t</a> nodeset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gac02ee8f7606382ea7855ae4e1656ed0f">hwloc_get_area_membind</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, const void *addr, size_t len, <a class="el" href="a00034.html#ga4bbf39b68b6f568fb92739e7c0ea7801">hwloc_cpuset_t</a> cpuset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *policy, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gac5586e58cf25c3596b7d4aa31ce13259">hwloc_alloc</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#gaeaa00714a9c4319bda0a74ca6f8720e8">hwloc_alloc_membind_nodeset</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, size_t len, <a class="el" href="a00034.html#ga2f5276235841ad66a79bedad16a5a10c">hwloc_const_nodeset_t</a> nodeset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> policy, int flags) </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga221a7edc5d436300374fa16463f607e5">hwloc_alloc_membind</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, size_t len, <a class="el" href="a00034.html#ga1f784433e9b606261f62d1134f6a3b25">hwloc_const_cpuset_t</a> cpuset, <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> policy, int flags) </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ga986d9b4cc76da592c4b937c6cb7d9d56">hwloc_free</a> (<a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a> topology, void *addr, size_t len)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all operating systems support all ways to bind existing allocated memory (e.g., migration), future memory allocation, explicit memory allocation, etc. Using a binding flag or policy that is not supported by the underlying OS will cause hwloc's binding functions to fail and return -1. errno will be set to ENOSYS when the system does support the specified action or policy (e.g., some systems only allow binding memory on a per-thread basis, whereas other systems only allow binding memory for all threads in a process). errno will be set to EXDEV when the requested cpuset can not be enforced (e.g., some systems only allow binding memory to a single NUMA node).</dd></dl>
<p>The most portable form that should be preferred over the others whenever possible is as follows:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="a00052.html#ga6178c6a9ec1dd88ec9f6a9fcdcc7d634" title="Allocate some memory on the memory nodes near given cpuset cpuset.">hwloc_alloc_membind_policy</a>(topology, size, <span class="keyword">set</span>, 
                            <a class="code" href="a00044.html#ggac9764f79505775d06407b40f5e4661e8a18675bb80ebc1bce5b652e9de8f3998c" title="Reset the memory allocation policy to the system default.">HWLOC_MEMBIND_DEFAULT</a>, 0);
</pre></div><p>This will allocate some memory hopefully bound to the specified set. To do so, hwloc will possibly have to change the current memory binding policy in order to actually get the memory bound, if the OS does not provide any other way to simply allocate bound memory without changing the policy for all allocations. That is the difference with <a class="el" href="a00044.html#ga221a7edc5d436300374fa16463f607e5" title="Allocate some memory on memory nodes near the given cpuset cpuset.">hwloc_alloc_membind()</a>, which will never change the current memory binding policy. Note that since HWLOC_MEMBIND_STRICT was not specified, failures to bind will not be reported -- generally, only memory allocation failures will be reported (e.g., even a plain malloc() would have failed with ENOMEM).</p>
<p>Each hwloc memory binding function is available in two forms: one that takes a CPU set argument and another that takes a NUMA memory node set argument (see <a class="el" href="a00034.html">Object sets (hwloc_cpuset_t and hwloc_nodeset_t)</a> and <a class="el" href="a00057.html">The bitmap API</a> for a discussion of CPU sets and NUMA memory node sets). The names of the latter form end with _nodeset. It is also possible to convert between CPU set and node set using <a class="el" href="a00055.html#ga60ecc4ae480c28b5fbd34aca4fc37daa" title="Convert a CPU set into a NUMA node set and handle non-NUMA cases.">hwloc_cpuset_to_nodeset()</a> or <a class="el" href="a00055.html#gaa677fd588304b5615de4ea78104adfb5" title="Convert a NUMA node set into a CPU set and handle non-NUMA cases.">hwloc_cpuset_from_nodeset()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>On some operating systems, memory binding affects the CPU binding; see <a class="el" href="a00044.html#ggab00475fd98815bf4fb9aaf752030e7d2aad6b9eaf2ee324ca58dc8f58094b9997" title="Avoid any effect on CPU binding.">HWLOC_MEMBIND_NOCPUBIND</a> </dd></dl>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gab00475fd98815bf4fb9aaf752030e7d2"></a><!-- doxytag: member="hwloc.h::hwloc_membind_flags_t" ref="gab00475fd98815bf4fb9aaf752030e7d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00044.html#gab00475fd98815bf4fb9aaf752030e7d2">hwloc_membind_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Memory binding flags. </p>
<p>These flags can be used to refine the binding policy. All flags can be logically OR'ed together with the exception of HWLOC_MEMBIND_PROCESS and HWLOC_MEMBIND_THREAD; these two flags are mutually exclusive.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all systems support all kinds of binding. See the "Detailed Description" section of <a class="el" href="a00044.html">Memory binding</a> for a description of errors that can occur. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4"></a><!-- doxytag: member="HWLOC_MEMBIND_PROCESS" ref="ggab00475fd98815bf4fb9aaf752030e7d2a1b1b74aef138f64aff214a8cbdfe8eb4" args="" -->HWLOC_MEMBIND_PROCESS</em>&nbsp;</td><td>
<p>Set policy for all threads of the specified (possibly multithreaded) process. This flag is mutually exclusive with HWLOC_MEMBIND_THREAD. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298"></a><!-- doxytag: member="HWLOC_MEMBIND_THREAD" ref="ggab00475fd98815bf4fb9aaf752030e7d2a1dc7dd5cdcd5796893a325a524555298" args="" -->HWLOC_MEMBIND_THREAD</em>&nbsp;</td><td>
<p>Set policy for a specific thread of the current process. This flag is mutually exclusive with HWLOC_MEMBIND_PROCESS. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6"></a><!-- doxytag: member="HWLOC_MEMBIND_STRICT" ref="ggab00475fd98815bf4fb9aaf752030e7d2a0335311a0ee04166df2888d52b4a42c6" args="" -->HWLOC_MEMBIND_STRICT</em>&nbsp;</td><td>
<p>Request strict binding from the OS. The function will fail if the binding can not be guaranteed / completely enforced.</p>
<p>This flag has slightly different meanings depending on which function it is used with. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab00475fd98815bf4fb9aaf752030e7d2aa6e49e54f52827cb143cc869cfd748af"></a><!-- doxytag: member="HWLOC_MEMBIND_MIGRATE" ref="ggab00475fd98815bf4fb9aaf752030e7d2aa6e49e54f52827cb143cc869cfd748af" args="" -->HWLOC_MEMBIND_MIGRATE</em>&nbsp;</td><td>
<p>Migrate existing allocated memory. If the memory cannot be migrated and the HWLOC_MEMBIND_STRICT flag is passed, an error will be returned. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab00475fd98815bf4fb9aaf752030e7d2aad6b9eaf2ee324ca58dc8f58094b9997"></a><!-- doxytag: member="HWLOC_MEMBIND_NOCPUBIND" ref="ggab00475fd98815bf4fb9aaf752030e7d2aad6b9eaf2ee324ca58dc8f58094b9997" args="" -->HWLOC_MEMBIND_NOCPUBIND</em>&nbsp;</td><td>
<p>Avoid any effect on CPU binding. </p>
<p>On some operating systems, some underlying memory binding functions also bind the application to the corresponding CPU(s). Using this flag will cause hwloc to avoid using OS functions that could potentially affect CPU bindings. Note, however, that using NOCPUBIND may reduce hwloc's overall memory binding support. Specifically: some of hwloc's memory binding functions may fail with errno set to ENOSYS when used with NOCPUBIND. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gac9764f79505775d06407b40f5e4661e8"></a><!-- doxytag: member="hwloc.h::hwloc_membind_policy_t" ref="gac9764f79505775d06407b40f5e4661e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Memory binding policy. </p>
<p>These constants can be used to choose the binding policy. Only one policy can be used at a time (i.e., the values cannot be OR'ed together).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all systems support all kinds of binding. See the "Detailed Description" section of <a class="el" href="a00044.html">Memory binding</a> for a description of errors that can occur. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggac9764f79505775d06407b40f5e4661e8a18675bb80ebc1bce5b652e9de8f3998c"></a><!-- doxytag: member="HWLOC_MEMBIND_DEFAULT" ref="ggac9764f79505775d06407b40f5e4661e8a18675bb80ebc1bce5b652e9de8f3998c" args="" -->HWLOC_MEMBIND_DEFAULT</em>&nbsp;</td><td>
<p>Reset the memory allocation policy to the system default. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac9764f79505775d06407b40f5e4661e8a979c7aa78dd32780858f30f47a72cca0"></a><!-- doxytag: member="HWLOC_MEMBIND_FIRSTTOUCH" ref="ggac9764f79505775d06407b40f5e4661e8a979c7aa78dd32780858f30f47a72cca0" args="" -->HWLOC_MEMBIND_FIRSTTOUCH</em>&nbsp;</td><td>
<p>Allocate memory but do not immediately bind it to a specific locality. Instead, each page in the allocation is bound only when it is first touched. Pages are individually bound to the local NUMA node of the first thread that touches it. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac9764f79505775d06407b40f5e4661e8ad811fa4b2a6002c4d63695a408ffde2c"></a><!-- doxytag: member="HWLOC_MEMBIND_BIND" ref="ggac9764f79505775d06407b40f5e4661e8ad811fa4b2a6002c4d63695a408ffde2c" args="" -->HWLOC_MEMBIND_BIND</em>&nbsp;</td><td>
<p>Allocate memory on the specified nodes. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac9764f79505775d06407b40f5e4661e8ae370075e5af016d42310f87ea5af236b"></a><!-- doxytag: member="HWLOC_MEMBIND_INTERLEAVE" ref="ggac9764f79505775d06407b40f5e4661e8ae370075e5af016d42310f87ea5af236b" args="" -->HWLOC_MEMBIND_INTERLEAVE</em>&nbsp;</td><td>
<p>Allocate memory on the given nodes in an interleaved / round-robin manner. The precise layout of the memory across multiple NUMA nodes is OS/system specific. Interleaving can be useful when threads distributed across the specified NUMA nodes will all be accessing the whole memory range concurrently, since the interleave will then balance the memory references. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac9764f79505775d06407b40f5e4661e8afb37480fe5f4236eb7dd4aef26f691e9"></a><!-- doxytag: member="HWLOC_MEMBIND_REPLICATE" ref="ggac9764f79505775d06407b40f5e4661e8afb37480fe5f4236eb7dd4aef26f691e9" args="" -->HWLOC_MEMBIND_REPLICATE</em>&nbsp;</td><td>
<p>Replicate memory on the given nodes; reads from this memory will attempt to be serviced from the NUMA node local to the reading thread. Replicating can be useful when multiple threads from the specified NUMA nodes will be sharing the same read-only data. </p>
<p>This policy can only be used with existing memory allocations (i.e., the hwloc_set_*membind*() functions); it cannot be used with functions that allocate new memory (i.e., the hwloc_alloc*() functions). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac9764f79505775d06407b40f5e4661e8aecdd4164d647708fbb51a00d98dbb138"></a><!-- doxytag: member="HWLOC_MEMBIND_NEXTTOUCH" ref="ggac9764f79505775d06407b40f5e4661e8aecdd4164d647708fbb51a00d98dbb138" args="" -->HWLOC_MEMBIND_NEXTTOUCH</em>&nbsp;</td><td>
<p>For each page bound with this policy, by next time it is touched (and next time only), it is moved from its current location to the local NUMA node of the thread where the memory reference occurred (if it needs to be moved at all). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402"></a><!-- doxytag: member="HWLOC_MEMBIND_MIXED" ref="ggac9764f79505775d06407b40f5e4661e8a3185bd869b67817fb2bd5164bf360402" args="" -->HWLOC_MEMBIND_MIXED</em>&nbsp;</td><td>
<p>Returned by hwloc_get_membind*() functions when multiple threads or parts of a memory area have differing memory binding policies. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gac5586e58cf25c3596b7d4aa31ce13259"></a><!-- doxytag: member="hwloc.h::hwloc_alloc" ref="gac5586e58cf25c3596b7d4aa31ce13259" args="(hwloc_topology_t topology, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> void* hwloc_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate some memory. </p>
<p>This is equivalent to malloc(), except that it tries to allocate page-aligned memory from the OS.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The allocated memory should be freed with <a class="el" href="a00044.html#ga986d9b4cc76da592c4b937c6cb7d9d56" title="Free memory that was previously allocated by hwloc_alloc() or hwloc_alloc_membind().">hwloc_free()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga221a7edc5d436300374fa16463f607e5"></a><!-- doxytag: member="hwloc.h::hwloc_alloc_membind" ref="ga221a7edc5d436300374fa16463f607e5" args="(hwloc_topology_t topology, size_t len, hwloc_const_cpuset_t cpuset, hwloc_membind_policy_t policy, int flags) " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> void* hwloc_alloc_membind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga1f784433e9b606261f62d1134f6a3b25">hwloc_const_cpuset_t</a>&#160;</td>
          <td class="paramname"><em>cpuset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate some memory on memory nodes near the given cpuset <code>cpuset</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 with errno set to ENOSYS if the action is not supported and HWLOC_MEMBIND_STRICT is given </dd>
<dd>
-1 with errno set to EXDEV if the binding cannot be enforced and HWLOC_MEMBIND_STRICT is given</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The allocated memory should be freed with <a class="el" href="a00044.html#ga986d9b4cc76da592c4b937c6cb7d9d56" title="Free memory that was previously allocated by hwloc_alloc() or hwloc_alloc_membind().">hwloc_free()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaa00714a9c4319bda0a74ca6f8720e8"></a><!-- doxytag: member="hwloc.h::hwloc_alloc_membind_nodeset" ref="gaeaa00714a9c4319bda0a74ca6f8720e8" args="(hwloc_topology_t topology, size_t len, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags) " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> void* hwloc_alloc_membind_nodeset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga2f5276235841ad66a79bedad16a5a10c">hwloc_const_nodeset_t</a>&#160;</td>
          <td class="paramname"><em>nodeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate some memory on the given nodeset <code>nodeset</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 with errno set to ENOSYS if the action is not supported and HWLOC_MEMBIND_STRICT is given </dd>
<dd>
-1 with errno set to EXDEV if the binding cannot be enforced and HWLOC_MEMBIND_STRICT is given</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The allocated memory should be freed with <a class="el" href="a00044.html#ga986d9b4cc76da592c4b937c6cb7d9d56" title="Free memory that was previously allocated by hwloc_alloc() or hwloc_alloc_membind().">hwloc_free()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga986d9b4cc76da592c4b937c6cb7d9d56"></a><!-- doxytag: member="hwloc.h::hwloc_free" ref="ga986d9b4cc76da592c4b937c6cb7d9d56" args="(hwloc_topology_t topology, void *addr, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory that was previously allocated by <a class="el" href="a00044.html#gac5586e58cf25c3596b7d4aa31ce13259" title="Allocate some memory.">hwloc_alloc()</a> or <a class="el" href="a00044.html#ga221a7edc5d436300374fa16463f607e5" title="Allocate some memory on memory nodes near the given cpuset cpuset.">hwloc_alloc_membind()</a>. </p>

</div>
</div>
<a class="anchor" id="gac02ee8f7606382ea7855ae4e1656ed0f"></a><!-- doxytag: member="hwloc.h::hwloc_get_area_membind" ref="gac02ee8f7606382ea7855ae4e1656ed0f" args="(hwloc_topology_t topology, const void *addr, size_t len, hwloc_cpuset_t cpuset, hwloc_membind_policy_t *policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_get_area_membind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga4bbf39b68b6f568fb92739e7c0ea7801">hwloc_cpuset_t</a>&#160;</td>
          <td class="paramname"><em>cpuset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the CPUs near the NUMA node(s) and binding policy of the memory identified by (<code>addr</code>, <code>len</code> ). </p>
<p>This function has two output parameters: <code>cpuset</code> and <code>policy</code>. The values returned in these parameters depend on both the <code>flags</code> passed in and the memory binding policies and nodesets of the pages in the address range.</p>
<p>If HWLOC_MEMBIND_STRICT is specified, the target pages are first checked to see if they all have the same memory binding policy and nodeset. If they do not, -1 is returned and errno is set to EXDEV. If they are identical across all pages, the policy is returned in <code>policy</code>. <code>cpuset</code> is set to the union of CPUs near the NUMA node(s) in the nodeset.</p>
<p>If HWLOC_MEMBIND_STRICT is not specified, the union of all NUMA node(s) containing pages in the address range is calculated. <code>cpuset</code> is then set to the CPUs near the NUMA node(s) in this union. If all pages in the target have the same policy, it is returned in <code>policy</code>. Otherwise, <code>policy</code> is set to HWLOC_MEMBIND_MIXED.</p>
<p>If any other flags are specified, -1 is returned and errno is set to EINVAL. </p>

</div>
</div>
<a class="anchor" id="ga106e6fcd764d17be682faf7a5bc95720"></a><!-- doxytag: member="hwloc.h::hwloc_get_area_membind_nodeset" ref="ga106e6fcd764d17be682faf7a5bc95720" args="(hwloc_topology_t topology, const void *addr, size_t len, hwloc_nodeset_t nodeset, hwloc_membind_policy_t *policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_get_area_membind_nodeset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga37e35730fa7e775b5bb0afe893d6d508">hwloc_nodeset_t</a>&#160;</td>
          <td class="paramname"><em>nodeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the NUMA node(s) and binding policy of the memory identified by (<code>addr</code>, <code>len</code> ). </p>
<p>This function has two output parameters: <code>nodeset</code> and <code>policy</code>. The values returned in these parameters depend on both the <code>flags</code> passed in and the memory binding policies and nodesets of the pages in the address range.</p>
<p>If HWLOC_MEMBIND_STRICT is specified, the target pages are first checked to see if they all have the same memory binding policy and nodeset. If they do not, -1 is returned and errno is set to EXDEV. If they are identical across all pages, the nodeset and policy are returned in <code>nodeset</code> and <code>policy</code>, respectively.</p>
<p>If HWLOC_MEMBIND_STRICT is not specified, <code>nodeset</code> is set to the union of all NUMA node(s) containing pages in the address range. If all pages in the target have the same policy, it is returned in <code>policy</code>. Otherwise, <code>policy</code> is set to HWLOC_MEMBIND_MIXED.</p>
<p>If any other flags are specified, -1 is returned and errno is set to EINVAL. </p>

</div>
</div>
<a class="anchor" id="gab07aedba1119f99130e5f0b796b7d8a5"></a><!-- doxytag: member="hwloc.h::hwloc_get_membind" ref="gab07aedba1119f99130e5f0b796b7d8a5" args="(hwloc_topology_t topology, hwloc_cpuset_t cpuset, hwloc_membind_policy_t *policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_get_membind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga4bbf39b68b6f568fb92739e7c0ea7801">hwloc_cpuset_t</a>&#160;</td>
          <td class="paramname"><em>cpuset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the default memory binding policy and locality of the current process or thread (the locality is returned in <code>cpuset</code> as CPUs near the locality's actual NUMA node(s)). </p>
<p>This function has two output parameters: <code>cpuset</code> and <code>policy</code>. The values returned in these parameters depend on both the <code>flags</code> passed in and the current memory binding policies and nodesets in the queried target.</p>
<p>Passing the HWLOC_MEMBIND_PROCESS flag specifies that the query target is the current policies and nodesets for all the threads in the current process. Passing HWLOC_MEMBIND_THREAD specifies that the query target is the current policy and nodeset for only the thread invoking this function.</p>
<p>If neither of these flags are passed (which is the most portable method), the process is assumed to be single threaded. This allows hwloc to use either process-based OS functions or thread-based OS functions, depending on which are available.</p>
<p>HWLOC_MEMBIND_STRICT is only meaningful when HWLOC_MEMBIND_PROCESS is also specified. In this case, hwloc will check the default memory policies and nodesets for all threads in the process. If they are not identical, -1 is returned and errno is set to EXDEV. If they are identical, the policy is returned in <code>policy</code>. <code>cpuset</code> is set to the union of CPUs near the NUMA node(s) in the nodeset.</p>
<p>Otherwise, if HWLOC_MEMBIND_PROCESS is specified (and HWLOC_MEMBIND_STRICT is <em>not</em> specified), the default nodeset from each thread is logically OR'ed together. <code>cpuset</code> is set to the union of CPUs near the NUMA node(s) in the resulting nodeset. If all threads' default policies are the same, <code>policy</code> is set to that policy. If they are different, <code>policy</code> is set to HWLOC_MEMBIND_MIXED.</p>
<p>In the HWLOC_MEMBIND_THREAD case (or when neither HWLOC_MEMBIND_PROCESS or HWLOC_MEMBIND_THREAD is specified), there is only one nodeset and policy. The policy is returned in <code>policy</code>; <code>cpuset</code> is set to the union of CPUs near the NUMA node(s) in the <code>nodeset</code>.</p>
<p>If any other flags are specified, -1 is returned and errno is set to EINVAL. </p>

</div>
</div>
<a class="anchor" id="ga7b46a4ca0b2db9723ca73b0c148ccd93"></a><!-- doxytag: member="hwloc.h::hwloc_get_membind_nodeset" ref="ga7b46a4ca0b2db9723ca73b0c148ccd93" args="(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_membind_policy_t *policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_get_membind_nodeset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga37e35730fa7e775b5bb0afe893d6d508">hwloc_nodeset_t</a>&#160;</td>
          <td class="paramname"><em>nodeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the default memory binding policy and locality of the current process or thread. </p>
<p>This function has two output parameters: <code>nodeset</code> and <code>policy</code>. The values returned in these parameters depend on both the <code>flags</code> passed in and the current memory binding policies and nodesets in the queried target.</p>
<p>Passing the HWLOC_MEMBIND_PROCESS flag specifies that the query target is the current policies and nodesets for all the threads in the current process. Passing HWLOC_MEMBIND_THREAD specifies that the query target is the current policy and nodeset for only the thread invoking this function.</p>
<p>If neither of these flags are passed (which is the most portable method), the process is assumed to be single threaded. This allows hwloc to use either process-based OS functions or thread-based OS functions, depending on which are available.</p>
<p>HWLOC_MEMBIND_STRICT is only meaningful when HWLOC_MEMBIND_PROCESS is also specified. In this case, hwloc will check the default memory policies and nodesets for all threads in the process. If they are not identical, -1 is returned and errno is set to EXDEV. If they are identical, the values are returned in <code>nodeset</code> and <code>policy</code>.</p>
<p>Otherwise, if HWLOC_MEMBIND_PROCESS is specified (and HWLOC_MEMBIND_STRICT is <em>not</em> specified), <code>nodeset</code> is set to the logical OR of all threads' default nodeset. If all threads' default policies are the same, <code>policy</code> is set to that policy. If they are different, <code>policy</code> is set to HWLOC_MEMBIND_MIXED.</p>
<p>In the HWLOC_MEMBIND_THREAD case (or when neither HWLOC_MEMBIND_PROCESS or HWLOC_MEMBIND_THREAD is specified), there is only one nodeset and policy; they are returned in <code>nodeset</code> and <code>policy</code>, respectively.</p>
<p>If any other flags are specified, -1 is returned and errno is set to EINVAL. </p>

</div>
</div>
<a class="anchor" id="gabaf9c13f1fa301d6895594cec52226e2"></a><!-- doxytag: member="hwloc.h::hwloc_get_proc_membind" ref="gabaf9c13f1fa301d6895594cec52226e2" args="(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_cpuset_t cpuset, hwloc_membind_policy_t *policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_get_proc_membind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga4bbf39b68b6f568fb92739e7c0ea7801">hwloc_cpuset_t</a>&#160;</td>
          <td class="paramname"><em>cpuset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the default memory binding policy and locality of the specified process (the locality is returned in <code>cpuset</code> as CPUs near the locality's actual NUMA node(s)). </p>
<p>This function has two output parameters: <code>cpuset</code> and <code>policy</code>. The values returned in these parameters depend on both the <code>flags</code> passed in and the current memory binding policies and nodesets in the queried target.</p>
<p>Passing the HWLOC_MEMBIND_PROCESS flag specifies that the query target is the current policies and nodesets for all the threads in the specified process. If HWLOC_MEMBIND_PROCESS is not specified (which is the most portable method), the process is assumed to be single threaded. This allows hwloc to use either process-based OS functions or thread-based OS functions, depending on which are available.</p>
<p>Note that it does not make sense to pass HWLOC_MEMBIND_THREAD to this function.</p>
<p>If HWLOC_MEMBIND_STRICT is specified, hwloc will check the default memory policies and nodesets for all threads in the specified process. If they are not identical, -1 is returned and errno is set to EXDEV. If they are identical, the policy is returned in <code>policy</code>. <code>cpuset</code> is set to the union of CPUs near the NUMA node(s) in the nodeset.</p>
<p>Otherwise, the default nodeset from each thread is logically OR'ed together. <code>cpuset</code> is set to the union of CPUs near the NUMA node(s) in the resulting nodeset. If all threads' default policies are the same, <code>policy</code> is set to that policy. If they are different, <code>policy</code> is set to HWLOC_MEMBIND_MIXED.</p>
<p>If any other flags are specified, -1 is returned and errno is set to EINVAL. </p>

</div>
</div>
<a class="anchor" id="ga22074ed072e1039f74f17f7b16e9e39d"></a><!-- doxytag: member="hwloc.h::hwloc_get_proc_membind_nodeset" ref="ga22074ed072e1039f74f17f7b16e9e39d" args="(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_nodeset_t nodeset, hwloc_membind_policy_t *policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_get_proc_membind_nodeset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga37e35730fa7e775b5bb0afe893d6d508">hwloc_nodeset_t</a>&#160;</td>
          <td class="paramname"><em>nodeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the default memory binding policy and locality of the specified process. </p>
<p>This function has two output parameters: <code>nodeset</code> and <code>policy</code>. The values returned in these parameters depend on both the <code>flags</code> passed in and the current memory binding policies and nodesets in the queried target.</p>
<p>Passing the HWLOC_MEMBIND_PROCESS flag specifies that the query target is the current policies and nodesets for all the threads in the specified process. If HWLOC_MEMBIND_PROCESS is not specified (which is the most portable method), the process is assumed to be single threaded. This allows hwloc to use either process-based OS functions or thread-based OS functions, depending on which are available.</p>
<p>Note that it does not make sense to pass HWLOC_MEMBIND_THREAD to this function.</p>
<p>If HWLOC_MEMBIND_STRICT is specified, hwloc will check the default memory policies and nodesets for all threads in the specified process. If they are not identical, -1 is returned and errno is set to EXDEV. If they are identical, the values are returned in <code>nodeset</code> and <code>policy</code>.</p>
<p>Otherwise, <code>nodeset</code> is set to the logical OR of all threads' default nodeset. If all threads' default policies are the same, <code>policy</code> is set to that policy. If they are different, <code>policy</code> is set to HWLOC_MEMBIND_MIXED.</p>
<p>If any other flags are specified, -1 is returned and errno is set to EINVAL. </p>

</div>
</div>
<a class="anchor" id="ga06594edeb4728cb9e014aed924d1e74a"></a><!-- doxytag: member="hwloc.h::hwloc_set_area_membind" ref="ga06594edeb4728cb9e014aed924d1e74a" args="(hwloc_topology_t topology, const void *addr, size_t len, hwloc_const_cpuset_t cpuset, hwloc_membind_policy_t policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_set_area_membind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga1f784433e9b606261f62d1134f6a3b25">hwloc_const_cpuset_t</a>&#160;</td>
          <td class="paramname"><em>cpuset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind the already-allocated memory identified by (addr, len) to the NUMA node(s) near <code>cpuset</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 with errno set to ENOSYS if the action is not supported </dd>
<dd>
-1 with errno set to EXDEV if the binding cannot be enforced </dd></dl>

</div>
</div>
<a class="anchor" id="gade5e2c28ea8475a479bf2b1df36c6ccd"></a><!-- doxytag: member="hwloc.h::hwloc_set_area_membind_nodeset" ref="gade5e2c28ea8475a479bf2b1df36c6ccd" args="(hwloc_topology_t topology, const void *addr, size_t len, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_set_area_membind_nodeset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga2f5276235841ad66a79bedad16a5a10c">hwloc_const_nodeset_t</a>&#160;</td>
          <td class="paramname"><em>nodeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind the already-allocated memory identified by (addr, len) to the NUMA node(s) in <code>nodeset</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 with errno set to ENOSYS if the action is not supported </dd>
<dd>
-1 with errno set to EXDEV if the binding cannot be enforced </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b6d1d90227aff8e44ef26bc1f8a8f95"></a><!-- doxytag: member="hwloc.h::hwloc_set_membind" ref="ga8b6d1d90227aff8e44ef26bc1f8a8f95" args="(hwloc_topology_t topology, hwloc_const_cpuset_t cpuset, hwloc_membind_policy_t policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_set_membind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga1f784433e9b606261f62d1134f6a3b25">hwloc_const_cpuset_t</a>&#160;</td>
          <td class="paramname"><em>cpuset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the default memory binding policy of the current process or thread to prefer the NUMA node(s) near the specified <code>cpuset</code>. </p>
<p>If neither HWLOC_MEMBIND_PROCESS nor HWLOC_MEMBIND_THREAD is specified, the current process is assumed to be single-threaded. This is the most portable form as it permits hwloc to use either process-based OS functions or thread-based OS functions, depending on which are available.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 with errno set to ENOSYS if the action is not supported </dd>
<dd>
-1 with errno set to EXDEV if the binding cannot be enforced </dd></dl>

</div>
</div>
<a class="anchor" id="ga747962cbb16fd12ad6d126011c734a27"></a><!-- doxytag: member="hwloc.h::hwloc_set_membind_nodeset" ref="ga747962cbb16fd12ad6d126011c734a27" args="(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_set_membind_nodeset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga2f5276235841ad66a79bedad16a5a10c">hwloc_const_nodeset_t</a>&#160;</td>
          <td class="paramname"><em>nodeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the default memory binding policy of the current process or thread to prefer the NUMA node(s) specified by <code>nodeset</code>. </p>
<p>If neither HWLOC_MEMBIND_PROCESS nor HWLOC_MEMBIND_THREAD is specified, the current process is assumed to be single-threaded. This is the most portable form as it permits hwloc to use either process-based OS functions or thread-based OS functions, depending on which are available.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 with errno set to ENOSYS if the action is not supported </dd>
<dd>
-1 with errno set to EXDEV if the binding cannot be enforced </dd></dl>

</div>
</div>
<a class="anchor" id="gac63c4517e71b3f0d41b3dee3e83dc55c"></a><!-- doxytag: member="hwloc.h::hwloc_set_proc_membind" ref="gac63c4517e71b3f0d41b3dee3e83dc55c" args="(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_const_cpuset_t cpuset, hwloc_membind_policy_t policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_set_proc_membind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga1f784433e9b606261f62d1134f6a3b25">hwloc_const_cpuset_t</a>&#160;</td>
          <td class="paramname"><em>cpuset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the default memory binding policy of the specified process to prefer the NUMA node(s) near the specified <code>cpuset</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 with errno set to ENOSYS if the action is not supported </dd>
<dd>
-1 with errno set to EXDEV if the binding cannot be enforced </dd></dl>

</div>
</div>
<a class="anchor" id="gaf10d18cd4703ec980d7440a1c23fa07f"></a><!-- doxytag: member="hwloc.h::hwloc_set_proc_membind_nodeset" ref="gaf10d18cd4703ec980d7440a1c23fa07f" args="(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int hwloc_set_proc_membind_nodeset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#ga9d1e76ee15a7dee158b786c30b6a6e38">hwloc_topology_t</a>&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwloc_pid_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00034.html#ga2f5276235841ad66a79bedad16a5a10c">hwloc_const_nodeset_t</a>&#160;</td>
          <td class="paramname"><em>nodeset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html#gac9764f79505775d06407b40f5e4661e8">hwloc_membind_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the default memory binding policy of the specified process to prefer the NUMA node(s) specified by <code>nodeset</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 with errno set to ENOSYS if the action is not supported </dd>
<dd>
-1 with errno set to EXDEV if the binding cannot be enforced </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 2 2011 07:16:30 for Hardware Locality (hwloc) by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>

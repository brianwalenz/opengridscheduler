<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Hardware Locality (hwloc): Frequently Asked Questions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hardware Locality (hwloc)&#160;<span id="projectnumber">1.2.2</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Frequently Asked Questions </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="faq_xml"></a>
I do not want hwloc to rediscover my enormous machine topology every time I rerun a process</h2>
<p>Although the topology discovery is not expensive on common machines, its overhead may become significant when multiple processes repeat the discovery on large machines (for instance when starting one process per core in a parallel application). The machine topology usually does not vary much, except if some cores are stopped/restarted or if the administrator restrictions are modified. Thus rediscovering the whole topology again and again may look useless.</p>
<p>For this purpose, hwloc offers XML import/export features. It lets you save the discovered topology to a file (for instance with the lstopo program) and reload it later by setting the HWLOC_XMLFILE environment variable. Loading a XML topology is usually much faster than querying multiple files or calling multiple functions of the operating system. It is also possible to manipulate such XML files with the C programming interface, and the import/export may also be directed to memory buffer (that may for instance be transmitted between applications through a socket).</p>
<h2><a class="anchor" id="faq_onedim"></a>
hwloc only has a one-dimensional view of the architecture, it ignores distances</h2>
<p>hwloc places all objects in a tree. Each level is a one-dimensional view of a set of similar objects. All children of the same object (siblings) are assumed to be equally interconnected (same distance between any of them), while the distance between children of different objects (cousins) is supposed to be larger.</p>
<p>Modern machines exhibit complex hardware interconnects, so this tree may miss some information about the actual physical distances between objects. The hwloc topology may therefore be annotated with distance information that may be used to build a more realistic representation (multi-dimensional) of each level. For instance, the root object may contain a distance matrix that represents the latencies between any pairs of NUMA nodes if the BIOS and/or operating system reports them.</p>
<h2><a class="anchor" id="faq_smt"></a>
How may I ignore symmetric multithreading, hyper-threading, ... ?</h2>
<p>hwloc creates one PU (processing unit) object per hardware thread. If your machine supports symmetric multithreading, for instance Hyper-Threading, each Core object may contain multiple PU objects. </p>
<div class="fragment"><pre class="fragment">
$ lstopo -
...
  Core L#1
    PU L#2 (P#1)
    PU L#3 (P#3)
</pre></div><p>If you need to ignore symmetric multithreading, you should likely manipulate hwloc Core objects directly: </p>
<div class="fragment"><pre class="fragment">
/* get the number of cores */
unsigned nbcores = hwloc_get_nbobjs_by_type(topology, HWLOC_OBJ_CORE);
...
/* get the third core below the first socket */
hwloc_obj_t socket, core;
socket = hwloc_get_obj_by_type(topology, HWLOC_OBJ_SOCKET, 0);
core = hwloc_get_obj_inside_cpuset_by_type(topology, socket-&gt;cpuset,
                                           HWLOC_OBJ_CORE, 2);
</pre></div><p>Whenever you want to bind a process or thread to a core, make sure you singlify its cpuset first, so that the task is actually bound to a single thread within this core (to avoid useless migrations). </p>
<div class="fragment"><pre class="fragment">
/* bind on the second core */
hwloc_obj_t core = hwloc_get_obj_by_type(topology, HWLOC_OBJ_CORE, 1);
hwloc_cpuset_t set = hwloc_bitmap_dup(core-&gt;cpuset);
hwloc_bitmap_singlify(set);
hwloc_set_cpubind(topology, set, 0);
hwloc_bitmap_free(set);
</pre></div><p>With hwloc-calc or hwloc-bind command-line tools, you may specify that you only want a single-thread within each core by asking for their first PU object: </p>
<div class="fragment"><pre class="fragment">
$ hwloc-calc core:4-7
0x0000ff00
$ hwloc-calc core:4-7.pu:0
0x00005500
</pre></div><p>When binding a process on the command-line, you may either specify the exact thread that you want to use, or ask hwloc-bind to singlify the cpuset before binding </p>
<div class="fragment"><pre class="fragment">
$ hwloc-bind core:3.pu:0 -- echo "hello from first thread on core #3"
hello from first thread on core #3
...
$ hwloc-bind core:3 --single -- echo "hello from a single thread on core #3"
hello from a single thread on core #3
</pre></div><h2><a class="anchor" id="faq_asymmetric"></a>
What happens if my topology is asymmetric?</h2>
<p>hwloc supports asymmetric topologies even if most platforms are usually symmetric. For example, there may be different types of processors in a single machine, each with different numbers of cores, symmetric multithreading, or levels of caches.</p>
<p>To understand how hwloc manages such cases, one should first remember the meaning of levels and cousin objects. All objects of the same type are gathered as horizontal levels with a given depth. They are also connected through the cousin pointers of the <a class="el" href="a00012.html" title="Structure of a topology object.">hwloc_obj</a> structure. Some types, such as Caches or Groups, are usually annotated with a depth or level attribute (for instance L2 cache). In this case, this attribute is also taken in account when gathering objects as horizontal levels. To be clear: there will be one level for L1 caches, another level for L2 caches, etc.</p>
<p>If the topology is asymmetric (e.g., if a cache is missing in one of the processors), a given horizontal level will still exist if there exist any objects of that type. However, some branches of the overall tree may not have an object located in that horizontal level. Note that this specific hole within one horizontal level does not imply anything for other levels. All objects of the same type are gathered in horizontal levels even if their parents or children have different depths and types.</p>
<p>Moreover, it is important to understand that a same parent object may have children of different types (and therefore, different depths). <b>These children are therefore siblings (because they have the same parent), but they are <em>not</em> cousins (because they do not belong to the same horizontal levels).</b></p>
<h2><a class="anchor" id="faq_annotate"></a>
How do I annotate the topology with private notes?</h2>
<p>Each hwloc object contains a <code>userdata</code> field that may be used by applications to store private pointers. This field is kept intact as long as the object is valid, which means as long as topology objects are not modified by reloading or restricting the topology.</p>
<p>It is also possible to insert Misc objects with custom names anywhere in the topology (<code><a class="el" href="a00039.html#ga017a9ba16d554326c6e3812d545d7230" title="Add a MISC object to the topology.">hwloc_topology_insert_misc_object_by_cpuset()</a></code>) or as a leaf of the topology (<code><a class="el" href="a00039.html#gadacd7a3d21220fbb30c3256d8b22a294" title="Add a MISC object as a leaf of the topology.">hwloc_topology_insert_misc_object_by_parent()</a></code>).</p>
<h2><a class="anchor" id="faq_upgrade"></a>
How do I handle API upgrades?</h2>
<p>The hwloc interface is extended with every new major release. Any application using the hwloc API should be prepared to check at compile-time whether some features are available in the currently installed hwloc distribution.</p>
<p>To check whether hwloc is at least 1.2, you should use: </p>
<div class="fragment"><pre class="fragment">
#include &lt;hwloc.h&gt;
#if HWLOC_API_VERSION &gt;= 0x00010200
...
#endif
</pre></div><p>One of the major changes in hwloc 1.1 was the addition of the bitmap API. It supersedes the now deprecated cpuset API which will be removed in a future hwloc release. It is strongly recommended to switch existing codes to the bitmap API. Keeping support for older hwloc versions is easy. For instance, if your code uses <code>hwloc_cpuset_alloc</code>, you should use <code>hwloc_bitmap_alloc</code> instead and add the following code to one of your common headers: </p>
<div class="fragment"><pre class="fragment">
#include &lt;hwloc.h&gt;
#if HWLOC_API_VERSION &lt; 0x00010100
#define hwloc_bitmap_alloc hwloc_cpuset_alloc
#endif
</pre></div><p>Similarly, the hwloc 1.0 interface may be detected by comparing <code>HWLOC_API_VERSION</code> with <code>0x00010000</code>.</p>
<p>hwloc 0.9 did not define any <code>HWLOC_API_VERSION</code> but this very old release probably does not deserve support from your application anymore. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 2 2011 07:16:30 for Hardware Locality (hwloc) by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
